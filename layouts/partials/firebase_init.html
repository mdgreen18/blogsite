<script id="firebase-post-init">
(function() { // Start of IIFE (Immediately Invoked Function Expression)

    // Check for the Firebase functions to be loaded before executing this script
    if (typeof window.getPostLikes === 'undefined') {
        // This is safe to ignore in a SPA environment if firebase.js loads asynchronously
        // but it signals an issue if it doesn't eventually load.
        console.warn("Firebase core functions not fully loaded yet.");
        return;
    }
    
    // --- The Post ID is passed directly from the Hugo context ---
    const postID = '{{ .File.UniqueID }}'; 
    if (!postID) {
        console.error("Post ID is missing. Cannot initialize Firebase features.");
        return;
    }
    
    // --- Variable Definitions (use postID for unique element IDs) ---
    const likeCountSpan = document.getElementById(`like-count-${postID}`);
    const likeButton = document.getElementById(`like-button-${postID}`);
    const commentsListContainer = document.getElementById(`comments-list-${postID}`);
    const commentForm = document.getElementById(`comment-form-${postID}`);
    const commentCountSpan = document.getElementById(`comment-count-${postID}`);
    
    // --- LIKE BUTTON LOGIC (Prevent multiple likes using Local Storage) ---

    // Disable button if already liked in this browser
    if (localStorage.getItem(`liked-${postID}`)) {
        if (likeButton) {
            likeButton.disabled = true;
        }
    }

    // Load initial likes
    window.getPostLikes(postID, (count) => {
      if (likeCountSpan) {
        likeCountSpan.textContent = count;
      }
    });

    // Handle like button click (This function is now defined here, but the onclick in the HTML must be updated)
    // NOTE: This global function definition is redundant if your HTML calls the button with data-post-id and you use an event listener.
    // However, if the theme's HTML is hard to change, keep this:
    window.handleLikeClick = (postID) => {
      if (localStorage.getItem(`liked-${postID}`)) {
        alert('You have already liked this post!');
        return;
      }

      window.incrementPostLikes(postID, (newCount) => {
        if (likeCountSpan) {
            likeCountSpan.textContent = newCount;
        }
        localStorage.setItem(`liked-${postID}`, 'true');
        if (likeButton) {
            likeButton.disabled = true;
        }
      });
    };
    
    // --- COMMENT LOGIC (Nested/Threaded) ---

    function buildCommentTree(comments) {
        const map = {};
        const tree = [];
        comments.forEach(comment => {
            map[comment.id] = { ...comment, replies: [] };
        });
        
        comments.forEach(comment => {
            if (comment.parentID && map[comment.parentID]) {
                map[comment.parentID].replies.push(map[comment.id]);
            } else {
                tree.push(map[comment.id]);
            }
        });
        return tree;
    }

    function renderComment(commentData, listElement) {
        const commentDiv = document.createElement('div');
        commentDiv.className = commentData.parentID ? 'comment reply' : 'comment top-level';
        commentDiv.innerHTML = `
            <div class="comment-header">
                <strong>${commentData.username}</strong>
                <small>${new Date(commentData.timestamp).toLocaleString()}</small>
            </div>
            <p>${commentData.comment.replace(/\n/g, '<br>')}</p>
            <button class="reply-button" data-comment-id="${commentData.id}">Reply</button>
            <div id="reply-form-container-${commentData.id}"></div>
        `;
        listElement.appendChild(commentDiv);

        if (commentData.replies && commentData.replies.length > 0) {
            const repliesList = document.createElement('div');
            repliesList.className = 'replies-list';
            commentData.replies.forEach(reply => {
                renderComment(reply, repliesList);
            });
            commentDiv.appendChild(repliesList);
        }
    }

    // --- Main function to load and render comments ---
    function reloadComments() {
        window.loadComments(postID, (flatComments) => {
            if (commentCountSpan) {
                 commentCountSpan.textContent = flatComments.length;
            }
            commentsListContainer.innerHTML = ''; // Clear previous
            const commentTree = buildCommentTree(flatComments);
            commentTree.forEach(comment => renderComment(comment, commentsListContainer));
        });
    }

    reloadComments();

    // --- EVENT: Handle top-level comment submission ---
    // Note: The listener must be re-attached every time this script runs.
    if (commentForm) {
        // First, remove any existing listener to prevent duplicate submissions on SPA navigation
        // For simplicity with an IIFE, we just attach a new listener, knowing the old one's closure will be garbage collected later.
        commentForm.addEventListener('submit', function submitHandler(e) {
            e.preventDefault();
            const usernameInput = commentForm.querySelector('.comment-username');
            const commentInput = commentForm.querySelector('.comment-text');
            
            if (!usernameInput.value || !commentInput.value) return;

            window.saveComment(postID, usernameInput.value, commentInput.value, null)
                .then(() => {
                    commentInput.value = '';
                    reloadComments();
                })
                .catch(error => {
                    console.error("Error saving comment:", error);
                    alert("Failed to post comment. Check security rules/network.");
                });
        });
    }

    // --- EVENT: Handle 'Reply' button clicks (Delegation) ---
    // Note: Event delegation is naturally handled by the SPA navigation, but we re-attach the listener here anyway
    if (commentsListContainer) {
        commentsListContainer.addEventListener('click', function replyHandler(e) {
            if (e.target.classList.contains('reply-button')) {
                const parentID = e.target.dataset.commentId;
                const formContainer = document.getElementById(`reply-form-container-${parentID}`);

                // Toggle form visibility
                if (formContainer.innerHTML) {
                    formContainer.innerHTML = '';
                    return;
                }

                // Create and append the reply form
                formContainer.innerHTML = `
                    <form class="reply-form">
                        <input type="text" placeholder="Your Name" required class="comment-username">
                        <textarea placeholder="Your reply..." required class="comment-text"></textarea>
                        <button type="submit">Post Reply</button>
                    </form>
                `;

                // EVENT: Handle reply form submission
                formContainer.querySelector('.reply-form').addEventListener('submit', (ev) => {
                    ev.preventDefault();
                    const form = ev.target;
                    const usernameInput = form.querySelector('.comment-username');
                    const commentInput = form.querySelector('.comment-text');

                    if (!usernameInput.value || !commentInput.value) return;

                    window.saveComment(postID, usernameInput.value, commentInput.value, parentID)
                        .then(() => {
                            formContainer.innerHTML = ''; // Clear form on success
                            reloadComments();
                        })
                        .catch(error => {
                            console.error("Error saving reply:", error);
                            alert("Failed to post reply. Check security rules/network.");
                        });
                });
            }
        });
    }

})(); // End of IIFE
</script>
